package com.haoxueche.mz200alib.camera2;

import android.annotation.SuppressLint;
import android.content.Context;
import android.graphics.ImageFormat;
import android.graphics.Matrix;
import android.graphics.Rect;
import android.graphics.RectF;
import android.graphics.SurfaceTexture;
import android.hardware.camera2.CameraAccessException;
import android.hardware.camera2.CameraCaptureSession;
import android.hardware.camera2.CameraCharacteristics;
import android.hardware.camera2.CameraDevice;
import android.hardware.camera2.CameraManager;
import android.hardware.camera2.CameraMetadata;
import android.hardware.camera2.CaptureRequest;
import android.hardware.camera2.CaptureResult;
import android.hardware.camera2.TotalCaptureResult;
import android.hardware.camera2.params.Face;
import android.media.Image;
import android.media.ImageReader;
import android.media.ImageReader.OnImageAvailableListener;
import android.os.Handler;
import android.os.HandlerThread;
import android.support.annotation.NonNull;
import android.text.TextUtils;
import android.util.Log;
import android.view.Surface;
import android.view.TextureView;
import android.view.TextureView.SurfaceTextureListener;
import android.view.ViewTreeObserver.OnGlobalLayoutListener;
import android.widget.Toast;

import com.haoxueche.mz200alib.widget.FaceView1;
import com.haoxueche.winterlog.L;

import java.io.File;
import java.nio.ByteBuffer;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collections;
import java.util.List;
import java.util.concurrent.Semaphore;
import java.util.concurrent.TimeUnit;

import io.reactivex.Observable;
import io.reactivex.Observer;
import io.reactivex.android.schedulers.AndroidSchedulers;
import io.reactivex.disposables.Disposable;


/**
 * Created by Lyc(987424501@qq.com) on 2018/5/23.
 */

public class Camera2Manager {
    public static final String TAG = "Camera2Manager";
    private Context context;

    /**
     * Camera state: Waiting for the focus to be locked.
     */
    private static final int STATE_WAITING_LOCK = 1;

    /**
     * Camera state: Waiting for the exposure to be precapture state.
     */
    private static final int STATE_WAITING_PRECAPTURE = 2;

    /**
     * Camera state: Waiting for the exposure state to be something other than precapture.
     */
    private static final int STATE_WAITING_NON_PRECAPTURE = 3;

    /**
     * Camera state: Picture was taken.
     */
    private static final int STATE_PICTURE_TAKEN = 4;

    /**
     * The facing of the camera is opposite to that of the screen.
     */
    private String cameraBack = "";

    /**
     * The facing of the camera is the same as that of the screen.
     */
    private String cameraFront = "";

    public static final int PIC_WIDTH = 640;
    public static final int PIC_HEIGHT = 480;

    /**
     * A {@link Handler} for running tasks in the background.
     */
    private Handler mBackgroundHandler;

    /**
     * An {@link ImageReader} that handles still image capture.
     */
    private ImageReader mCaptureImageReader;

    /**
     * An {@link ImageReader} that receive preview frame data callback.
     */
    private ImageReader mPreviewImageReader;

    /**
     * An additional thread for running tasks that shouldn't block the UI.
     */
    private HandlerThread mBackgroundThread;


    private CameraManager cameraManager;

    private String mCameraId;

    /**
     * A {@link Semaphore} to prevent the app from exiting before closing the camera.
     */
    private Semaphore mCameraOpenCloseLock = new Semaphore(1);

    /**
     * A reference to the opened {@link CameraDevice}.
     */
    private CameraDevice mCameraDevice;

    private TextureView mTextureView;

    private Surface textureSurface;

    /**
     * A {@link CameraCaptureSession } for camera preview.
     */
    private CameraCaptureSession mCaptureSession;

    /**
     * {@link CaptureRequest.Builder} for the camera preview
     */
    private CaptureRequest.Builder mPreviewRequestBuilder;

    /**
     * {@link CaptureRequest} generated by {@link #mPreviewRequestBuilder}
     */
    private CaptureRequest mPreviewRequest;

    /**
     * Camera state: Showing camera preview.
     */
    private static final int STATE_PREVIEW = 0;

    /**
     * The current state of camera state for taking pictures.
     *
     * @see #mCaptureCallback
     */
    private int mState = STATE_PREVIEW;

    private int cameraCount = 0;

    private boolean cameraRotate; //相机旋转180度

    /**
     * Whether the current camera device supports Flash or not.
     */
    private boolean mFlashSupported;

    private PictureCallback pictureCallback;

    private int cameraActiveWidth;
    private int cameraActiveHeight;

    private FaceView1 faceView;
    private int faceDetectMode;
    private FaceDectionListener faceDectionListener;

    private volatile boolean released = false;

    private boolean isFrontCamera;

    private boolean flashOn;

    private boolean cameraError;
    private long processTime;
    boolean isCheckPreView;
    private boolean drawFaceArea = true;

    private OnImageCallbackListener mOnImageCallbackListener;

    public interface PictureCallback {
        void onPictureTake(byte[] data);

        void onCameraError();

        void onCameraBlocked();//相机卡住了
    }

    public interface FaceDectionListener {
        void onFaceDect(Face[] faces);
    }

    public interface OnImageCallbackListener {
        /**
         * Callback that is called when a new image is available from ImageReader.
         *
         * @param reader the ImageReader the callback is associated with.
         * @see ImageReader
         * @see Image
         */
        void onImageCallback(ImageReader reader);
    }

    /**
     * {@link CameraDevice.StateCallback} is called when {@link CameraDevice} changes its state.
     */
    private final CameraDevice.StateCallback mStateCallback = new CameraDevice.StateCallback() {

        @Override
        public void onOpened(@NonNull CameraDevice cameraDevice) {
            L.w( "onOpened");
            // This method is called when the camera is opened.  We start camera preview here.
            mCameraOpenCloseLock.release();
            //出错关闭了的不打开
            if (released) {
                return;
            }
            mCameraDevice = cameraDevice;
            SurfaceTexture texture = mTextureView.getSurfaceTexture();
            if (texture != null) {
                createCameraPreviewSession();
            } else {
                mTextureView.setSurfaceTextureListener(new SurfaceTextureListener() {
                    @Override
                    public void onSurfaceTextureAvailable(SurfaceTexture surface, int width, int
                            height) {
                        createCameraPreviewSession();
                    }

                    @Override
                    public void onSurfaceTextureSizeChanged(SurfaceTexture surface, int width,
                                                            int height) {

                    }

                    @Override
                    public boolean onSurfaceTextureDestroyed(SurfaceTexture surface) {
                        return false;
                    }

                    @Override
                    public void onSurfaceTextureUpdated(SurfaceTexture surface) {

                    }
                });
            }
        }

        @Override
        public void onDisconnected(@NonNull CameraDevice cameraDevice) {
            L.w( "onDisconnected");
            release();
        }

        /**
         * @see #ERROR_CAMERA_IN_USE
         * @see #ERROR_MAX_CAMERAS_IN_USE
         * @see #ERROR_CAMERA_DISABLED
         * @see #ERROR_CAMERA_DEVICE
         * @see #ERROR_CAMERA_SERVICE
         * @param cameraDevice
         * @param error
         */
        @Override
        public void onError(@NonNull CameraDevice cameraDevice, int error) {
            L.w( "onError==" + error + " " + released);
            if (released) {
                return;
            }
            L.w( "onError1==" + pictureCallback);
            if (pictureCallback != null) {
                pictureCallback.onCameraError();
                pictureCallback = null;
            }
            release();
        }

    };

    public static Camera2Manager newInstance(Context context) {
        Camera2Manager camera2Manager = new Camera2Manager();
        camera2Manager.setContext(context);
        return camera2Manager;
    }

    public static Camera2Manager newInstance(Context context, TextureView textureView, boolean
            cameraRotate, PictureCallback pictureCallback) {
        Camera2Manager manager = new Camera2Manager();
        manager.setContext(context);
        manager.setTextureView(textureView);
        manager.setCameraRotate(cameraRotate);
        manager.setPictureCallback(pictureCallback);
        manager.init();
        return manager;
    }


    public static Camera2Manager newInstance(Context context, TextureView textureView, FaceView1
            faceView
            , FaceDectionListener faceDectionListener, boolean cameraRotate, boolean
                                                     isFrontCamera, boolean flashOn, PictureCallback
                                                     pictureCallback) {
        L.w( "cameraRotate==" + cameraRotate + " isFrontCamera" + isFrontCamera);
        Camera2Manager manager = new Camera2Manager();
        manager.setContext(context);
        manager.setTextureView(textureView);
        manager.setCameraRotate(cameraRotate);
        manager.setPictureCallback(pictureCallback);
        manager.setFaceView(faceView);
        manager.setFaceDectionListener(faceDectionListener);
        manager.setFrontCamera(isFrontCamera);
        manager.setFlashOn(flashOn);
        manager.init();
        return manager;
    }

    private Camera2Manager() {

    }

    public PictureCallback getPictureCallback() {
        return pictureCallback;
    }

    public void setPictureCallback(PictureCallback pictureCallback) {
        this.pictureCallback = pictureCallback;
    }

    public boolean isCameraRotate() {
        return cameraRotate;
    }

    public void setCameraRotate(boolean cameraRotate) {
        this.cameraRotate = cameraRotate;
    }

    @SuppressLint("MissingPermission")
    public void init() {
        cameraManager = (CameraManager) context.getSystemService(Context.CAMERA_SERVICE);
        startBackgroundThread();
        mCaptureImageReader = ImageReader.newInstance(PIC_WIDTH, PIC_HEIGHT,
                ImageFormat.JPEG, /*maxImages*/1);
        mCaptureImageReader.setOnImageAvailableListener(
                mOnCaptureImageAvailableListener, mBackgroundHandler);

        try {
            cameraCount = 0;
            for (String cameraId : cameraManager.getCameraIdList()) {
                CameraCharacteristics characteristics
                        = cameraManager.getCameraCharacteristics(cameraId);
                Integer facing = characteristics.get(CameraCharacteristics.LENS_FACING);
                if (facing != null) {
                    cameraCount++;
                    if (facing == CameraCharacteristics.LENS_FACING_FRONT) {
                        cameraFront = cameraId;
                        if (cameraManager.getCameraIdList().length == 1) {
                            cameraBack = cameraFront;
                        }
                    } else if (facing == CameraCharacteristics.LENS_FACING_BACK) {
                        cameraBack = cameraId;
                        if (cameraManager.getCameraIdList().length == 1) {
                            cameraFront = cameraBack;
                        }
                    }
                }
                if ((isFrontCamera && TextUtils.equals(cameraId, cameraFront))
                        || (!isFrontCamera && TextUtils.equals(cameraId, cameraBack))) {
                    Rect rect = characteristics.get(CameraCharacteristics
                            .SENSOR_INFO_ACTIVE_ARRAY_SIZE);
                    cameraActiveWidth = rect.width();
                    cameraActiveHeight = rect.height();
                    if (faceView != null) {
                        faceView.setActiveWidth(cameraActiveWidth);
                        faceView.setActiveHeight(cameraActiveHeight);
                    }
                    //获取人脸检测参数
                    int[] FD = characteristics.get(CameraCharacteristics
                            .STATISTICS_INFO_AVAILABLE_FACE_DETECT_MODES);
                    int maxFD = characteristics.get(CameraCharacteristics
                            .STATISTICS_INFO_MAX_FACE_COUNT);

                    if (FD.length > 0) {
                        List<Integer> fdList = new ArrayList<>();
                        for (int FaceD : FD
                                ) {
                            fdList.add(FaceD);
                            L.e( "setUpCameraOutputs: FD type:" + Integer.toString(FaceD));
                        }
                        L.e( "setUpCameraOutputs: FD count" + Integer.toString(maxFD));

                        if (maxFD > 0) {
                            faceDetectMode = Collections.max(fdList);
                            L.w( "faceDetectMode==" + faceDetectMode);
                        }
                    }

                    // Check if the flash is supported.
                    Boolean available = characteristics.get(CameraCharacteristics
                            .FLASH_INFO_AVAILABLE);
                    mFlashSupported = available == null ? false : available;
                }
            }
//            //只有1个摄像头可用
//            if (cameraCount == 1) {
//                if (!TextUtils.isEmpty(cameraFront)) {
//                    cameraBack = cameraFront;
//                } else if (!TextUtils.isEmpty(cameraBack)) {
//                    cameraFront = cameraBack;
//                }
//            }
            if (isFrontCamera) {
                mCameraId = cameraFront;
            } else {
                mCameraId = cameraBack;
            }
        } catch (CameraAccessException e) {
            L.e(e);
        }
        if (mTextureView.getViewTreeObserver().isAlive()) {
            rotateCamera1();
        } else {
            Observable.timer(500, TimeUnit.MILLISECONDS).observeOn(AndroidSchedulers.mainThread()
            ).subscribe(new Observer<Long>() {
                @Override
                public void onSubscribe(Disposable d) {

                }

                @Override
                public void onNext(Long aLong) {
                    if (mTextureView.getViewTreeObserver().isAlive()) {
                        rotateCamera1();
                    }
                }

                @Override
                public void onError(Throwable e) {
                    L.e(e);
                }

                @Override
                public void onComplete() {

                }
            });
        }
        if (faceView != null) {
            faceView.setFrontCamera(isCurrentFrontCamera() && cameraCount == 2);
            faceView.setRotate(cameraRotate);
        }
    }

    private void rotateCamera1() {
        mTextureView.getViewTreeObserver().addOnGlobalLayoutListener(new OnGlobalLayoutListener() {
            @Override
            public void onGlobalLayout() {
                L.w( "onGlobalLayout");
                mTextureView.getViewTreeObserver().removeOnGlobalLayoutListener(this);
                rotateCamera();
            }
        });
        mTextureView.post(new Runnable() {
            @Override
            public void run() {
                mTextureView.requestLayout(); //触发globallayout
            }
        });
    }

    private void rotateCamera() {
        Matrix matrix = new Matrix();
        RectF viewRect = new RectF(0, 0, mTextureView.getWidth(), mTextureView.getHeight());
        float centerX = viewRect.centerX();
        float centerY = viewRect.centerY();
        if (cameraRotate) {
            matrix.postRotate(180, centerX, centerY);
            mTextureView.setTransform(matrix);
        }
    }

    @SuppressLint("MissingPermission")
    public void openCamera() {
        if (TextUtils.isEmpty(mCameraId)) {
            L.e( "cameraId == null");
            return;
        }
        try {
            if (!mCameraOpenCloseLock.tryAcquire(2500, TimeUnit.MILLISECONDS)) {
                throw new RuntimeException("Time out waiting to lock camera opening.");
            }
            cameraManager.openCamera(mCameraId, mStateCallback, mBackgroundHandler);
        } catch (CameraAccessException e) {
            L.e(e);
        } catch (InterruptedException e) {
            throw new RuntimeException("Interrupted while trying to lock camera opening.", e);
        } catch (Exception e) {
            release();
            L.e(e);
        }
    }


    /**
     * This a callback object for the {@link ImageReader}. "onImageAvailable" will be called when a
     * still image is ready to be saved.
     */
    private final OnImageAvailableListener mOnCaptureImageAvailableListener
            = new OnImageAvailableListener() {

        @Override
        public void onImageAvailable(ImageReader reader) {
            mBackgroundHandler.post(new ImageSaver(reader.acquireNextImage(), pictureCallback,
                    Camera2Manager.this));
        }

    };

    private OnImageAvailableListener mOnPreviewImageAvailableListener;

    /**
     * Starts a background thread and its {@link Handler}.
     */
    public void startBackgroundThread() {
        L.w( "startBackgroundThread");
        mBackgroundThread = new HandlerThread("CameraBackground");
        mBackgroundThread.start();
        mBackgroundHandler = new Handler(mBackgroundThread.getLooper());
    }

    /**
     * Stops the background thread and its {@link Handler}.
     */
    public void stopBackgroundThread() {
        L.w( "stopBackgroundThread");
        if (mBackgroundThread != null) {
            mBackgroundThread.quitSafely();
            if (cameraError) {
                return;
            }
            try {
                mBackgroundThread.join();
                mBackgroundThread = null;
                mBackgroundHandler = null;
            } catch (InterruptedException e) {
                L.e(e);
            }
        }
    }


    /**
     * Saves a JPEG {@link Image} into the specified {@link File}.
     */
    private static class ImageSaver implements Runnable {

        /**
         * The JPEG image
         */
        private final Image mImage;

        private PictureCallback mPictureCallback;
        private Camera2Manager mCamera2Manager;

        ImageSaver(Image image, PictureCallback pictureCallback, Camera2Manager camera2Manager) {
            mImage = image;
            mPictureCallback = pictureCallback;
            mCamera2Manager = camera2Manager;
        }

        @Override
        public void run() {
            ByteBuffer buffer = mImage.getPlanes()[0].getBuffer();
            byte[] bytes = new byte[buffer.remaining()];
            buffer.get(bytes);
            if (mPictureCallback != null) {
                mPictureCallback.onPictureTake(bytes);
            }
            if (mCamera2Manager != null) {
                mCamera2Manager.setPictureCallback(null);
            }
            mImage.close();
        }

    }

    /**
     * Creates a new {@link CameraCaptureSession} for camera preview.
     */
    private void createCameraPreviewSession() {
        L.w( "createCameraPreviewSession");
        try {
            SurfaceTexture texture = mTextureView.getSurfaceTexture();

            // We configure the size of default buffer to be the size of camera preview we want.
            texture.setDefaultBufferSize(PIC_WIDTH, PIC_HEIGHT);

            // This is the output Surface we need to start preview.
            Surface surface = new Surface(texture);


            // We set up a CaptureRequest.Builder with the output Surface.
            mPreviewRequestBuilder
                    = mCameraDevice.createCaptureRequest(CameraDevice.TEMPLATE_PREVIEW);
            mPreviewRequestBuilder.addTarget(surface);

            if (mPreviewImageReader != null && mOnPreviewImageAvailableListener != null) {
                mPreviewImageReader.setOnImageAvailableListener(
                        mOnPreviewImageAvailableListener, mBackgroundHandler);
                mPreviewRequestBuilder.addTarget(mPreviewImageReader.getSurface());
            }

            mPreviewRequestBuilder.set(CaptureRequest.STATISTICS_FACE_DETECT_MODE,
                    faceDetectMode);
//            mPreviewRequestBuilder.set(CaptureRequest.FLASH_MODE,
//                    CaptureRequest.FLASH_MODE_TORCH);
            List<Surface> surfaceList;
            if (mPreviewImageReader != null) {
                surfaceList = Arrays.asList(surface, mCaptureImageReader
                        .getSurface(), mPreviewImageReader.getSurface());
            } else {
                surfaceList = Arrays.asList(surface, mCaptureImageReader
                        .getSurface());
            }
            // Here, we create a CameraCaptureSession for camera preview.
            mCameraDevice.createCaptureSession(surfaceList,
                    new CameraCaptureSession.StateCallback() {

                        @Override
                        public void onConfigured(@NonNull CameraCaptureSession
                                                         cameraCaptureSession) {
                            L.w( "onConfigured");
                            // The camera is already closed
                            if (null == mCameraDevice) {
                                return;
                            }

                            // When the session is ready, we start displaying the preview.
                            mCaptureSession = cameraCaptureSession;
                            try {
                                // Auto focus should be continuous for camera preview.
//                                mPreviewRequestBuilder.set(CaptureRequest.CONTROL_AF_MODE,
//                                        CaptureRequest.CONTROL_AF_MODE_CONTINUOUS_PICTURE);
//                                // Flash is automatically enabled when necessary.
                                setAutoFlash(mPreviewRequestBuilder);

                                // Finally, we start displaying the camera preview.
                                mPreviewRequest = mPreviewRequestBuilder.build();
                                mCaptureSession.setRepeatingRequest(mPreviewRequest,
                                        mCaptureCallback, mBackgroundHandler);
                                //在初始化Preview的时候启动监测子线程
                                PreViewErrorRunnable preViewErrorRunnable = new
                                        PreViewErrorRunnable();
                                isCheckPreView = true;
                                processTime = System.currentTimeMillis();   //防止PreView初始化不成功,
                                // 先给processTime赋值。
                                new Thread(preViewErrorRunnable).start();
                            } catch (CameraAccessException e) {
                                L.e(e);
                            }
                        }

                        @Override
                        public void onConfigureFailed(
                                @NonNull CameraCaptureSession cameraCaptureSession) {
                            L.w( "onConfigureFailed");
                            showToast("Failed");
                        }
                    }, null
            );
        } catch (CameraAccessException e) {
            L.e(e);
        }
    }

    private void setAutoFlash(CaptureRequest.Builder requestBuilder) {
        // Auto focus should be continuous for camera preview.
//        mPreviewRequestBuilder.set(CaptureRequest.CONTROL_AF_MODE,
//                CaptureRequest.CONTROL_AF_MODE_CONTINUOUS_PICTURE);
        if (mFlashSupported) {
            if (flashOn) {
                requestBuilder.set(CaptureRequest.CONTROL_AE_MODE,
                        CaptureRequest.CONTROL_AE_MODE_ON_ALWAYS_FLASH);
            } else {
                requestBuilder.set(CaptureRequest.CONTROL_AE_MODE,
                        CaptureRequest.CONTROL_AE_MODE_OFF);
            }
        }
    }


    /**
     * Shows a {@link Toast} on the UI thread.
     *
     * @param text The message to show
     */
    private void showToast(final String text) {
        L.e( text);
    }

    /**
     * A {@link CameraCaptureSession.CaptureCallback} that handles events related to JPEG capture.
     */
    private CameraCaptureSession.CaptureCallback mCaptureCallback
            = new CameraCaptureSession.CaptureCallback() {

        private void process(CaptureResult result) {
            L.d( "process   ===" + mState);
            processTime = System.currentTimeMillis();
            switch (mState) {
                case STATE_PREVIEW: {
                    //获得Face类
                    Face face[] = result.get(CaptureResult.STATISTICS_FACES);
                    if (drawFaceArea) {
                        Rect[] rects = new Rect[face.length];
                        for (int i = 0; i < rects.length; i++) {
                            rects[i] = face[i].getBounds();
                        }
                        faceView.setFaces(rects);
                    }
                    //如果有人脸的话
                    if (face.length > 0) {
                        L.e( "face detected " + Integer.toString(face.length));
                        //获取人脸矩形框
                        Rect bounds = face[0].getBounds();

                        Log.e("top", String.valueOf(bounds.top));
                        Log.e("bottom", String.valueOf(bounds.bottom));
                        Log.e("left", String.valueOf(bounds.left));
                        Log.e("right", String.valueOf(bounds.right));
                        if (faceDectionListener != null) {
                            faceDectionListener.onFaceDect(face);
                        }
                    }
                    break;
                }
                case STATE_WAITING_LOCK: {
                    Integer afState = result.get(CaptureResult.CONTROL_AF_STATE);
                    if (afState == null) {
                        L.w( "process  :  afState == null");
                        captureStillPicture();
                    } else if (CaptureResult.CONTROL_AF_STATE_FOCUSED_LOCKED == afState ||
                            CaptureResult.CONTROL_AF_STATE_NOT_FOCUSED_LOCKED == afState) {
                        L.w( "process  :  afState == " + afState);
                        // CONTROL_AE_STATE can be null on some devices
                        Integer aeState = result.get(CaptureResult.CONTROL_AE_STATE);
                        L.w( "process  :  aeState == " + aeState);
                        if (aeState == null ||
                                aeState == CaptureResult.CONTROL_AE_STATE_CONVERGED) {
                            mState = STATE_PICTURE_TAKEN;
                            captureStillPicture();
                        } else {
                            runPrecaptureSequence();
                        }
                    }
                    break;
                }
                case STATE_WAITING_PRECAPTURE: {
                    // CONTROL_AE_STATE can be null on some devices
                    Integer aeState = result.get(CaptureResult.CONTROL_AE_STATE);
                    if (aeState == null ||
                            aeState == CaptureResult.CONTROL_AE_STATE_PRECAPTURE ||
                            aeState == CaptureRequest.CONTROL_AE_STATE_FLASH_REQUIRED) {
                        mState = STATE_WAITING_NON_PRECAPTURE;
                    }
                    break;
                }
                case STATE_WAITING_NON_PRECAPTURE: {
                    // CONTROL_AE_STATE can be null on some devices
                    Integer aeState = result.get(CaptureResult.CONTROL_AE_STATE);
                    if (aeState == null || aeState != CaptureResult.CONTROL_AE_STATE_PRECAPTURE) {
                        mState = STATE_PICTURE_TAKEN;
                        captureStillPicture();
                    }
                    break;
                }
            }
        }

        @Override
        public void onCaptureProgressed(@NonNull CameraCaptureSession session,
                                        @NonNull CaptureRequest request,
                                        @NonNull CaptureResult partialResult) {
            process(partialResult);
        }

        @Override
        public void onCaptureCompleted(@NonNull CameraCaptureSession session,
                                       @NonNull CaptureRequest request,
                                       @NonNull TotalCaptureResult result) {
            process(result);
        }

    };


    class PreViewErrorRunnable implements Runnable {
        @Override
        public void run() {
            L.w( "PreViewErrorRunnable  :  runover");

            while (isCheckPreView) {
                try {
                    Thread.sleep(1000);
                    long time = System.currentTimeMillis();
                    long timeBetween = (time - processTime) / 1000;
                    L.w( "PreViewErrorRunnable  :  run");
                    if (timeBetween > 4) {
                        L.w("PreViewErrorRunnable  :  runover");
                        // L.w( "PreViewErrorRunnable  :  runover");
                        isCheckPreView = false;
//                      reOpenCamera();
                        if (pictureCallback != null) {
                           L.w(TAG, "pictureCallback  :  onCameraBlocked");
                            pictureCallback.onCameraBlocked();
                            pictureCallback = null;
                        }
                    }
                } catch (InterruptedException e) {
                    L.e(e);
                }
            }
        }
    }

    private void reOpenCamera() {
        //关闭相机连接
        try {
            mCameraOpenCloseLock.acquire();
            if (null != mCaptureSession) {
                mCaptureSession.close();
                mCaptureSession = null;
            }
            if (null != mCaptureImageReader) {
                mCaptureImageReader.close();
                mCaptureImageReader = null;
            }
        } catch (InterruptedException e) {
            throw new RuntimeException("Interrupted while trying to lock camera closing.", e);
        } finally {
            mCameraOpenCloseLock.release();
        }
        //重新建立连接
        createCameraPreviewSession();
    }


    /**
     * Capture a still picture. This method should be called when we get a response in
     */
    private void captureStillPicture() {
        L.w( "captureStillPicture");
        try {
            // This is the CaptureRequest.Builder that we use to take a picture.
            final CaptureRequest.Builder captureBuilder =
                    mCameraDevice.createCaptureRequest(CameraDevice.TEMPLATE_STILL_CAPTURE);
            captureBuilder.addTarget(mCaptureImageReader.getSurface());

            // Use the same AE and AF modes as the preview.
//            captureBuilder.set(CaptureRequest.CONTROL_AF_MODE,
//                    CaptureRequest.CONTROL_AF_MODE_CONTINUOUS_PICTURE);
            setAutoFlash(captureBuilder);

            if (cameraRotate) {
                // Orientation
                captureBuilder.set(CaptureRequest.JPEG_ORIENTATION, 180);
            }

            CameraCaptureSession.CaptureCallback captureCallback
                    = new CameraCaptureSession.CaptureCallback() {

                @Override
                public void onCaptureCompleted(@NonNull CameraCaptureSession session,
                                               @NonNull CaptureRequest request,
                                               @NonNull TotalCaptureResult result) {
                    unlockFocus();
                }
            };

            mCaptureSession.stopRepeating();
            mCaptureSession.abortCaptures();
            mCaptureSession.capture(captureBuilder.build(), captureCallback, null);
        } catch (CameraAccessException e) {
            L.e(e);
        }
    }

    /**
     * Unlock the focus. This method should be called when still image capture sequence is
     * finished.
     */
    private void unlockFocus() {
        try {
            // Reset the auto-focus trigger
            mPreviewRequestBuilder.set(CaptureRequest.CONTROL_AF_TRIGGER,
                    CameraMetadata.CONTROL_AF_TRIGGER_CANCEL);
            setAutoFlash(mPreviewRequestBuilder);
            mCaptureSession.capture(mPreviewRequestBuilder.build(), mCaptureCallback,
                    mBackgroundHandler);
            // After this, the camera will go back to the normal state of preview.
            mState = STATE_PREVIEW;
            mCaptureSession.setRepeatingRequest(mPreviewRequest, mCaptureCallback,
                    mBackgroundHandler);
        } catch (CameraAccessException e) {
            L.e(e);
        }
    }

    /**
     * Run the precapture sequence for capturing a still image. This method should be called when
     */
    private void runPrecaptureSequence() {
        L.w( "runPrecaptureSequence");
        try {
            // This is how to tell the camera to trigger.
            mPreviewRequestBuilder.set(CaptureRequest.CONTROL_AE_PRECAPTURE_TRIGGER,
                    CaptureRequest.CONTROL_AE_PRECAPTURE_TRIGGER_START);
            // Tell #mCaptureCallback to wait for the precapture sequence to be set.
            mState = STATE_WAITING_PRECAPTURE;
            mCaptureSession.capture(mPreviewRequestBuilder.build(), mCaptureCallback,
                    mBackgroundHandler);
        } catch (CameraAccessException e) {
            L.e(e);
        }
    }

    public TextureView getTextureView() {
        return mTextureView;
    }

    public void setTextureView(TextureView textureView) {
        this.mTextureView = textureView;
    }

    public void takePicture() {
        isCheckPreView = false;
        lockFocus();
    }

    /**
     * Lock the focus as the first step for a still image capture.
     */
    private void lockFocus() {
        L.w( "lockFocus");
        try {
            if (mPreviewRequestBuilder == null) {
                if (pictureCallback != null) {
                    pictureCallback.onCameraError();
                    pictureCallback = null;
                }
                return;
            }
            L.w( "lockFocus  mPreviewRequestBuilder != null");
            // This is how to tell the camera to lock focus.
            mPreviewRequestBuilder.set(CaptureRequest.CONTROL_AF_TRIGGER,
                    CameraMetadata.CONTROL_AF_TRIGGER_START);
            // Tell #mCaptureCallback to wait for the lock.
            mState = STATE_WAITING_LOCK;
            if (mCaptureSession != null) {
                mCaptureSession.capture(mPreviewRequestBuilder.build(), mCaptureCallback,
                        mBackgroundHandler);
            } else {
                cameraError = true;
            }
        } catch (CameraAccessException | IllegalStateException e) {
            L.e(e);
            L.w( "lockFocus ++ error");
        }
    }

    public void release() {
        if (released) {
            return;
        }
        isCheckPreView = false;
        released = true;
        faceView.setFaces(null);
        closeCamera();
        stopBackgroundThread();
    }

    public Context getContext() {
        return context;
    }

    public void setContext(Context context) {
        this.context = context;
    }

    /**
     * Closes the current {@link CameraDevice}.
     */
    private void closeCamera() {
        try {
            mCameraOpenCloseLock.acquire();
            if (null != mCaptureSession) {
                try {
                    mCaptureSession.stopRepeating();
                    mCaptureSession.abortCaptures();
                    mCaptureSession.close();
                    mCaptureSession = null;
                } catch (Exception e) {
                    L.e(e);
                }
            }
            if (null != mCameraDevice && !cameraError) {
                mCameraDevice.close();
                mCameraDevice = null;
            }
            if (mPreviewImageReader != null) {
                mPreviewImageReader.close();
                mPreviewImageReader = null;
            }
            if (null != mCaptureImageReader) {
                mCaptureImageReader.close();
                mCaptureImageReader = null;
            }
        } catch (InterruptedException e) {
            throw new RuntimeException("Interrupted while trying to lock camera closing.", e);
        } finally {
            mCameraOpenCloseLock.release();
        }
    }

    public FaceView1 getFaceView() {
        return faceView;
    }

    public void setFaceView(FaceView1 faceView) {
        this.faceView = faceView;
    }

    public FaceDectionListener getFaceDectionListener() {
        return faceDectionListener;
    }

    public void setFaceDectionListener(FaceDectionListener faceDectionListener) {
        this.faceDectionListener = faceDectionListener;
    }

    public boolean isFrontCamera() {
        return isFrontCamera;
    }

    public void setFrontCamera(boolean frontCamera) {
        isFrontCamera = frontCamera;
    }

    public int getCameraCount() {
        cameraManager = (CameraManager) context.getSystemService(Context.CAMERA_SERVICE);
        int cameraCount = 0;
        try {
            String[] cameraIdList = cameraManager.getCameraIdList();
            if (cameraIdList != null && cameraIdList.length > 0) {
                for (String cameraId : cameraManager.getCameraIdList()) {
                    CameraCharacteristics characteristics
                            = cameraManager.getCameraCharacteristics(cameraId);
                    Integer facing = characteristics.get(CameraCharacteristics.LENS_FACING);
                    // Check if the flash is supported.
                    Boolean available = characteristics.get(CameraCharacteristics
                            .FLASH_INFO_AVAILABLE);
                    mFlashSupported = available == null ? false : available;
                    if (facing != null) {
                        cameraCount++;
                    }
                }
            }
        } catch (CameraAccessException e) {
            L.e(e);
        }
        return cameraCount;
    }


    public boolean isFlashOn() {
        return flashOn;
    }

    public void setFlashOn(boolean flashOn) {
        this.flashOn = flashOn;
    }

    /**
     * @return 当前实际使用的是否是外置相机
     */
    public boolean isCurrentFrontCamera() {
        return TextUtils.equals(mCameraId, cameraFront);
    }

    public void setOnImageCallbackListener(OnImageCallbackListener imageCallbackListener) {
        setOnImageCallbackListener(imageCallbackListener, ImageFormat
                .YUV_420_888);
    }

    public void setOnImageCallbackListener(OnImageCallbackListener imageCallbackListener, int
            imageFormat) {
        L.w( "setOnImageCallbackListener");
        mOnImageCallbackListener = imageCallbackListener;
        if (imageCallbackListener != null) {
            L.w( "setOnImageCallbackListener11111");
            mOnPreviewImageAvailableListener = new OnImageAvailableListener() {
                @Override
                public void onImageAvailable(ImageReader reader) {
                    L.w( "onImageAvailable");
                    if (mOnImageCallbackListener != null) {
                        L.w( "onImageAvailable1111");
                        mOnImageCallbackListener.onImageCallback(reader);
                    }
                }
            };
            mPreviewImageReader = ImageReader.newInstance(PIC_WIDTH, PIC_HEIGHT,
                    imageFormat, /*maxImages*/1);
        }
    }

    public boolean isDrawFaceArea() {
        return drawFaceArea;
    }

    public void setDrawFaceArea(boolean drawFaceArea, int previewWidth, int previewHeight) {
        this.drawFaceArea = drawFaceArea;
        if (faceView != null) {
            faceView.setActiveWidth(previewWidth);
            faceView.setActiveHeight(previewHeight);
        }
    }
}
